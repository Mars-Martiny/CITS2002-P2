#include <stdio.h>
#include <stdlib.h>

#define NUM_PROCESSES 4       // Total number of processes
#define PAGES_PER_PROCESS 4   // Pages per process
#define RAM_SIZE 16           // Total RAM size (array length)
#define VM_SIZE (NUM_PROCESSES * PAGES_PER_PROCESS * 2) // Total Virtual Memory size
#define MAX_PAGES_IN_RAM 8    // Maximum pages that can fit in RAM

// Structure to represent a memory page with typedef
typedef struct {
    int process_id;    // Process ID
    int page_num;      // Page number of the process
    int last_accessed; // Last time the page was accessed
} Memory;

Memory *ram[MAX_PAGES_IN_RAM]; // Array representing RAM (can store 8 pages)
Memory *vm[VM_SIZE];           // Array representing Virtual Memory

int time_step = 0; // Simulation time step
int ram_page_count = 0; // Keeps track of how many pages are in RAM

// Function to initialize the memory pages
void initialize_memory() {
    int vm_index = 0; // Index for virtual memory

    // Initialize virtual memory
    for (int process_id = 0; process_id < NUM_PROCESSES; process_id++) {
        for (int page_num = 0; page_num < PAGES_PER_PROCESS; page_num++) {
            // Allocate memory for a new page
            Memory *page = (Memory *)malloc(sizeof(Memory));

            // Initialize the page fields
            page->process_id = process_id;
            page->page_num = page_num;
            page->last_accessed = 0; // Initialize last accessed time to 0

            // Store the pointer in the virtual memory array
            vm[vm_index++] = page;
        }
    }
}

// Function to find and replace a page in RAM using FIFO
void load_page_into_ram(Memory *page) {
    // If there is room in RAM, just add the page
    if (ram_page_count < MAX_PAGES_IN_RAM) {
        ram[ram_page_count] = page;
        ram_page_count++;
        printf("Loaded page (P%d, %d) into RAM at index %d\n", page->process_id, page->page_num, ram_page_count - 1);
    } else {
        // If RAM is full, implement FIFO to replace the oldest page
        Memory *evicted_page = ram[0]; // FIFO eviction: evict the first page in RAM
        printf("Evicting page (P%d, %d) from RAM.\n", evicted_page->process_id, evicted_page->page_num);

        // Shift all other pages forward
        for (int i = 1; i < MAX_PAGES_IN_RAM; i++) {
            ram[i - 1] = ram[i];
        }

        // Load the new page into the last slot of RAM
        ram[MAX_PAGES_IN_RAM - 1] = page;
        printf("Loaded page (P%d, %d) into RAM at index %d\n", page->process_id, page->page_num, MAX_PAGES_IN_RAM - 1);
    }
}

// Simulate page access
void access_page(int process_id, int page_num) {
    time_step++; // Increment the simulation time step

    // Check if the page is already in RAM
    for (int i = 0; i < ram_page_count; i++) {
        if (ram[i]->process_id == process_id && ram[i]->page_num == page_num) {
            // Page found in RAM, update last_accessed
            ram[i]->last_accessed = time_step;
            printf("Page (P%d, %d) accessed in RAM at time %d.\n", process_id, page_num, time_step);
            return;
        }
    }

    // If page not found in RAM, simulate page fault and load it
    printf("Page fault for page (P%d, %d) at time %d.\n", process_id, page_num, time_step);
    
    // Find the page in virtual memory and load it into RAM
    for (int i = 0; i < VM_SIZE; i++) {
        if (vm[i]->process_id == process_id && vm[i]->page_num == page_num) {
            load_page_into_ram(vm[i]);
            vm[i]->last_accessed = time_step;
            break;
        }
    }
}

void print_ram() {
    printf("\nRAM Contents:\n");
    for (int i = 0; i < MAX_PAGES_IN_RAM; i++) {
        if (ram[i] != NULL) {
            printf("RAM[%d]: Process ID = %d, Page Num = %d, Last Accessed = %d\n",
                i, ram[i]->process_id, ram[i]->page_num, ram[i]->last_accessed);
        }
    }
}

int main() {
    // Initialize the memory structures
    initialize_memory();

    // Simulate accessing different pages
    access_page(0, 0); // Process 0, Page 0
    access_page(1, 1); // Process 1, Page 1
    access_page(2, 2); // Process 2, Page 2
    access_page(3, 3); // Process 3, Page 3
    access_page(0, 1); // Process 0, Page 1
    access_page(1, 0); // Process 1, Page 0
    access_page(2, 3); // Process 2, Page 3
    access_page(3, 2); // Process 3, Page 2

    // Print the RAM contents
    print_ram();

    // Free allocated memory
    for (int i = 0; i < VM_SIZE; i++) {
        free(vm[i]); // Free each page in virtual memory
    }

    return 0;
}


INPUT: 0 2 0 0 0 0 

VM  :  [ 0, 0, 0 | 0, 0, 0 ; 0, 1, 2 | 0, 1, 2 ; 0, 2, 3 | 0, 2, 3 ; 0, 3, 4 | 0, 3, 4 ; 1, 0, 0 | 1, 0, 0 ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ]

RAM :  [ 0, 0, 5 | 0, 0, 5 ; 2, 0, 1 | 2, 0, 1 ; 0, 1, 2  | 0, 1, 2 ; 0, 2, 3 | 0, 2, 3 ; 0, 3, 4 | 0, 3, 4 ;  ;  ;  ]


Page tables for processes;

process 0:
            3, 2, 1, 99





VM  :  [ 0, 0, 0 | 0, 0, 0 ; 0, 1, 2 | 0, 1, 2 ; 0, 2, 3 | 0, 2, 3 ; 0, 3, 4 | 0, 3, 4 ; 1, 0, 0 | 1, 0, 0 ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ]

RAM :  [ ... ; 0, 2, - | 0, 2, - ; 0, 1, -  | 0, 1, - ; 0, 0, - | 0, 0, - ; ;  ;  ;  ]


Page tables for processes;

process 0:
            3, 2, 1, 99
